@page "/"
@using WakaSkies.WakaAPI;
@using WakaSkies.WakaModelBuilder;
@using BlazorDownloadFile;
@inject IJSRuntime JSRuntime;
@inject IBlazorDownloadFileService DownloadService;

@*https://threejs.org/manual/#en/tips#html-background*@
<canvas id="threeCanvas"></canvas>

@if (showIcons)
{
    <div class="icons">
        <button @onclick=ToggleHome>
            Hi
        </button>
        <p>
            <button @onclick=DownloadFile>
                Hi
            </button>
        </p>
    </div>
}

@if (showStartup)
{
    <div class="startup">
        <div>
            <span style="color: white">
                WakaTime JSON Data:
            </span>
            <p>
                <textarea @bind=jsonData style="position: relative"></textarea>
            </p>
        </div>

        <div>
            <button style="background-color: #333333; color: white; padding: 5px;"
                @onclick=ToggleSettings>Advanced Settings</button>
        </div>

        <button @onclick=Create style="width: 100%;">Go</button>
    </div>
}

@if (showSettings)
{
    <div class="settings-window">
        <span style="color: white">
            Hi!
        </span>
    </div>
}


@code{

    // the JSON data.
    string jsonData = "";

    bool showSettings;
    bool showStartup = true;
    bool showIcons;

    WakaModel model;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // create the scene.
            await JSRuntime.InvokeVoidAsync("createScene");
        }
    }

    void ToggleSettings() => showSettings = !showSettings;

    async void ToggleHome()
    {
        showStartup = !showStartup;
        showIcons = !showIcons;

        if (showStartup)
        {
            await JSRuntime.InvokeVoidAsync("pauseCamera");
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("pauseCamera");
        }
    }

    async void Create()
    {

        // key is not needed here.
        var client = new WakaClient("a");
        var insights = client.GetUserInsightsViaJSON(jsonData);

        var modelBuilder = new ModelBuilder();
        // preset info for time being.
        model = modelBuilder.BuildModel(new ModelBuildSettings() { Response = insights, Year = "2022" });

        // multiply by three because there are 3 floats per vertex and THREE.js 
        // requires each vertex one after another in a list
        float[] verts = new float[model.Vertices.Length * 3];
        // each vertex gets a normal
        float[] normals = new float[model.Vertices.Length * 3];

        var i = 0;
        var j = 0;
        var face = 0;
        var vertCount = 0;
        // create the normal and verts list.
        foreach (var vert in model.Vertices)
        {
            verts[i++] = vert.X;
            verts[i++] = vert.Y;
            verts[i++] = vert.Z;

            normals[j++] = model.Faces[face].Normal.X;
            normals[j++] = model.Faces[face].Normal.Y;
            normals[j++] = model.Faces[face].Normal.Z;

            vertCount++;
            if (vertCount >= 3)
            {
                face++;
                vertCount = 0;
            }
        }

        await JSRuntime.InvokeVoidAsync("setHalfWidth", model.Width / 2);

        // https://stackoverflow.com/a/64626309
        // The marshalled call to createModel takes a while. If unmarshalled calling is supported,
        // it uses it. This speeds up the JS interopt call drastically.
        if (JSRuntime is IJSUnmarshalledRuntime webAssemblyJSRuntime)
        {
            // call the function.
            // The true in the last param means it is unmarshalled.
            webAssemblyJSRuntime.InvokeUnmarshalled<float[], float[], bool, object>("createModel", verts, normals, true);
        }
        else
        {
            // call the JS function.
            // The true in the last param means it is marshalled.
            await JSRuntime.InvokeVoidAsync("createModel", verts, normals, false);
        }

        showStartup = false;
        showIcons = true;
        StateHasChanged();
    }

    public async void DownloadFile()
    {
        var serializer = new STLSerializer();
        var file = serializer.SerializeBinaryStream(model);

        //uncomment for ASCII
        //await DownloadService.DownloadFileFromText("WakaSkies Model.stl", file, System.Text.Encoding.UTF8, contentType: "text/plain", encoderShouldEmitIdentifier: false);

        // binary
        await DownloadService.DownloadFile("WakaSkies Model.stl", file.ToArray(), contentType: "application/octet-stream");
    }

}